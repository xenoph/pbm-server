{"version":3,"sources":["webpack://pbm/./node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js","webpack://pbm/./node_modules/apollo-cache-inmemory/node_modules/@wry/context/lib/context.esm.js","webpack://pbm/./node_modules/apollo-cache-inmemory/node_modules/optimism/lib/bundle.esm.js","webpack://pbm/./node_modules/apollo-cache-inmemory/lib/bundle.esm.js"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","currentContext","MISSING_VALUE","idCounter","globalKey","host","Slot","id","Date","now","Math","random","toString","slice","join","hasValue","context_1","parent","slots","value","getValue","withValue","callback","args","thisArg","_a","bind","context","saved","noContext","defineProperty","enumerable","writable","configurable","defaultDispose","Cache","max","dispose","Infinity","map","Map","newest","oldest","has","key","get","entry","getEntry","older","newer","set","clean","size","delete","parentEntrySlot","reusableEmptyArray","emptySetPool","assert","condition","optionalMessage","Error","valueGet","Entry","fn","parents","Set","childValues","dirtyChildren","dirty","recomputing","count","recompute","child","add","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","recomputeNewValue","subscribe","maybeUnsubscribe","unsubscribe","e","setDirty","maybeSubscribe","reportClean","setClean","forEach","reportDirty","_this","forgetChild","pop","a","len","childValue","removeDirtyChild","dc","push","reportOrphan","children","_value","KeyTrie","weakness","lookup","array","_i","lookupArray","node","getChildTrie","data","isObjRef","weak","WeakMap","strong","keyTrie","defaultMakeCacheKey","caches","wrap","originalFunction","options","cache","pow","disposable","makeCacheKey","optimistic","clear","haveWarned","HeuristicFragmentMatcher","ensureReady","Promise","resolve","canBypassInit","match","idValue","typeCondition","obj","store","isRootQuery","__typename","hasOwn","IntrospectionFragmentMatcher","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","implementingTypes","indexOf","introspectionResultData","typeMap","__schema","types","type","kind","name","possibleTypes","implementingType","DepTrackingCache","depend","dataId","toObject","replace","newData","keys","defaultNormalizedCacheFactory","seed","StoreReader","_b","_c","cacheKeyRoot","_d","freezeResults","_e","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","query","rootValue","contextValue","variableValues","fragmentMatcher","JSON","stringify","selectionSet","execContext","field","readQueryFromStore","diffQueryAgainstStore","returnPartialData","result","variables","previousResult","rootId","fragmentMatcherFunction","config","queryDefinition","dataIdFromObject","cacheRedirects","execResult","generated","typename","hasMissingFields","missing","info","tolerable","complete","defaultFragmentMatcher","mainDefinition","fragments","fragmentMap","finalResult","objectsToMerge","object","handleMissing","selections","selection","fieldResult","executeField","fragment","fragmentExecResult","readStoreResult","fieldName","directives","storeKeyName","fieldValue","resolver","getCacheKey","storeObj","json","readStoreResolver","resultKey","isArray","combineExecResults","assertSelectionSetForIdValue","execResults","childResult","item","ObjectCache","WriteError","_super","StoreWriter","writeQueryToStore","writeResultToStore","document","operationDefinition","writeSelectionSetToStore","processedData","error","enhancedError","message","stack","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","some","directive","matches","undefined","fakeContext","storeValue","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","index","itemDataId","generatedKey","realKey","real","madeChanges","realValue","newRealValue","defaultConfig","_id","addTypename","resultCaching","hasOwn$1","OptimisticCacheLayer","optimisticId","transaction","InMemoryCache","watches","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","c","restore","extract","read","transformDocument","write","broadcastWatches","diff","watch","evict","reset","removeOptimistic","idToRemove","toReapply","removedCount","layer","layer_1","performTransaction","recordOptimisticTransaction"],"mappings":"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","file":"npm.apollo-cache-inmemory.fd5647aa181e29ae7e67.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","// This currentContext variable will only be used if the makeSlotClass\r\n// function is called, which happens only if this is the first copy of the\r\n// @wry/context package to be imported.\r\nvar currentContext = null;\r\n// This unique internal object is used to denote the absence of a value\r\n// for a given Slot, and is never exposed to outside code.\r\nvar MISSING_VALUE = {};\r\nvar idCounter = 1;\r\n// Although we can't do anything about the cost of duplicated code from\r\n// accidentally bundling multiple copies of the @wry/context package, we can\r\n// avoid creating the Slot class more than once using makeSlotClass.\r\nvar makeSlotClass = function () { return /** @class */ (function () {\r\n    function Slot() {\r\n        // If you have a Slot object, you can find out its slot.id, but you cannot\r\n        // guess the slot.id of a Slot you don't have access to, thanks to the\r\n        // randomized suffix.\r\n        this.id = [\r\n            \"slot\",\r\n            idCounter++,\r\n            Date.now(),\r\n            Math.random().toString(36).slice(2),\r\n        ].join(\":\");\r\n    }\r\n    Slot.prototype.hasValue = function () {\r\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\r\n            // We use the Slot object iself as a key to its value, which means the\r\n            // value cannot be obtained without a reference to the Slot object.\r\n            if (this.id in context_1.slots) {\r\n                var value = context_1.slots[this.id];\r\n                if (value === MISSING_VALUE)\r\n                    break;\r\n                if (context_1 !== currentContext) {\r\n                    // Cache the value in currentContext.slots so the next lookup will\r\n                    // be faster. This caching is safe because the tree of contexts and\r\n                    // the values of the slots are logically immutable.\r\n                    currentContext.slots[this.id] = value;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        if (currentContext) {\r\n            // If a value was not found for this Slot, it's never going to be found\r\n            // no matter how many times we look it up, so we might as well cache\r\n            // the absence of the value, too.\r\n            currentContext.slots[this.id] = MISSING_VALUE;\r\n        }\r\n        return false;\r\n    };\r\n    Slot.prototype.getValue = function () {\r\n        if (this.hasValue()) {\r\n            return currentContext.slots[this.id];\r\n        }\r\n    };\r\n    Slot.prototype.withValue = function (value, callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        var _a;\r\n        var slots = (_a = {\r\n                __proto__: null\r\n            },\r\n            _a[this.id] = value,\r\n            _a);\r\n        var parent = currentContext;\r\n        currentContext = { parent: parent, slots: slots };\r\n        try {\r\n            // Function.prototype.apply allows the arguments array argument to be\r\n            // omitted or undefined, so args! is fine here.\r\n            return callback.apply(thisArg, args);\r\n        }\r\n        finally {\r\n            currentContext = parent;\r\n        }\r\n    };\r\n    // Capture the current context and wrap a callback function so that it\r\n    // reestablishes the captured context when called.\r\n    Slot.bind = function (callback) {\r\n        var context = currentContext;\r\n        return function () {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = context;\r\n                return callback.apply(this, arguments);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        };\r\n    };\r\n    // Immediately run a callback function without any captured context.\r\n    Slot.noContext = function (callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        if (currentContext) {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = null;\r\n                // Function.prototype.apply allows the arguments array argument to be\r\n                // omitted or undefined, so args! is fine here.\r\n                return callback.apply(thisArg, args);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        }\r\n        else {\r\n            return callback.apply(thisArg, args);\r\n        }\r\n    };\r\n    return Slot;\r\n}()); };\r\n// We store a single global implementation of the Slot class as a permanent\r\n// non-enumerable symbol property of the Array constructor. This obfuscation\r\n// does nothing to prevent access to the Slot class, but at least it ensures\r\n// the implementation (i.e. currentContext) cannot be tampered with, and all\r\n// copies of the @wry/context package (hopefully just one) will share the\r\n// same Slot implementation. Since the first copy of the @wry/context package\r\n// to be imported wins, this technique imposes a very high cost for any\r\n// future breaking changes to the Slot class.\r\nvar globalKey = \"@wry/context:Slot\";\r\nvar host = Array;\r\nvar Slot = host[globalKey] || function () {\r\n    var Slot = makeSlotClass();\r\n    try {\r\n        Object.defineProperty(host, globalKey, {\r\n            value: host[globalKey] = Slot,\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: false,\r\n        });\r\n    }\r\n    finally {\r\n        return Slot;\r\n    }\r\n}();\n\nvar bind = Slot.bind, noContext = Slot.noContext;\r\nfunction setTimeoutWithContext(callback, delay) {\r\n    return setTimeout(bind(callback), delay);\r\n}\r\n// Turn any generator function into an async function (using yield instead\r\n// of await), with context automatically preserved across yields.\r\nfunction asyncFromGen(genFn) {\r\n    return function () {\r\n        var gen = genFn.apply(this, arguments);\r\n        var boundNext = bind(gen.next);\r\n        var boundThrow = bind(gen.throw);\r\n        return new Promise(function (resolve, reject) {\r\n            function invoke(method, argument) {\r\n                try {\r\n                    var result = method.call(gen, argument);\r\n                }\r\n                catch (error) {\r\n                    return reject(error);\r\n                }\r\n                var next = result.done ? resolve : invokeNext;\r\n                if (isPromiseLike(result.value)) {\r\n                    result.value.then(next, result.done ? reject : invokeThrow);\r\n                }\r\n                else {\r\n                    next(result.value);\r\n                }\r\n            }\r\n            var invokeNext = function (value) { return invoke(boundNext, value); };\r\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\r\n            invokeNext();\r\n        });\r\n    };\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value && typeof value.then === \"function\";\r\n}\r\n// If you use the fibers npm package to implement coroutines in Node.js,\r\n// you should call this function at least once to ensure context management\r\n// remains coherent across any yields.\r\nvar wrappedFibers = [];\r\nfunction wrapYieldingFiberMethods(Fiber) {\r\n    // There can be only one implementation of Fiber per process, so this array\r\n    // should never grow longer than one element.\r\n    if (wrappedFibers.indexOf(Fiber) < 0) {\r\n        var wrap = function (obj, method) {\r\n            var fn = obj[method];\r\n            obj[method] = function () {\r\n                return noContext(fn, arguments, this);\r\n            };\r\n        };\r\n        // These methods can yield, according to\r\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\r\n        wrap(Fiber, \"yield\");\r\n        wrap(Fiber.prototype, \"run\");\r\n        wrap(Fiber.prototype, \"throwInto\");\r\n        wrappedFibers.push(Fiber);\r\n    }\r\n    return Fiber;\r\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };\n//# sourceMappingURL=context.esm.js.map\n","import { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar reusableEmptyArray = [];\r\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn, args) {\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        ++Entry.count;\r\n    }\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function () {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        if (!rememberParent(this) && maybeReportOrphan(this)) {\r\n            // The recipient of the entry.reportOrphan callback decided to dispose\r\n            // of this orphan entry by calling entry.dispose(), so we don't need to\r\n            // (and should not) proceed with the recomputation.\r\n            return void 0;\r\n        }\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this).forEach(maybeReportOrphan);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry) {\r\n    // Since this recomputation is likely to re-remember some of this\r\n    // entry's children, we forget our children here but do not call\r\n    // maybeReportOrphan until after the recomputation finishes.\r\n    var originalChildren = forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\r\n    if (maybeSubscribe(entry)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    // Now that we've had a chance to re-remember any children that were\r\n    // involved in the recomputation, we can safely report any orphan\r\n    // children that remain.\r\n    originalChildren.forEach(maybeReportOrphan);\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, entry.args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// If the given entry has a reportOrphan method, and no remaining parents,\r\n// call entry.reportOrphan and return true iff it returns true. The\r\n// reportOrphan function should return true to indicate entry.dispose()\r\n// has been called, and the entry has been removed from any other caches\r\n// (see index.js for the only current example).\r\nfunction maybeReportOrphan(entry) {\r\n    return entry.parents.size === 0 &&\r\n        typeof entry.reportOrphan === \"function\" &&\r\n        entry.reportOrphan() === true;\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    var children = reusableEmptyArray;\r\n    if (parent.childValues.size > 0) {\r\n        children = [];\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n            children.push(child);\r\n        });\r\n    }\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n    return children;\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, entry.args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\r\nfunction maybeUnsubscribe(entry) {\r\n    var unsubscribe = entry.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entry.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\n// A trie data structure that holds object keys weakly, yet can also hold\r\n// non-object keys, unlike the native `WeakMap`.\r\nvar KeyTrie = /** @class */ (function () {\r\n    function KeyTrie(weakness) {\r\n        this.weakness = weakness;\r\n    }\r\n    KeyTrie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    KeyTrie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        array.forEach(function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = Object.create(null));\r\n    };\r\n    KeyTrie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new KeyTrie(this.weakness));\r\n        return child;\r\n    };\r\n    return KeyTrie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var disposable = !!options.disposable;\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        if (disposable && !parentEntrySlot.hasValue()) {\r\n            // If there's no current parent computation, and this wrapped\r\n            // function is disposable (meaning we don't care about entry.value,\r\n            // just dependency tracking), then we can short-cut everything else\r\n            // in this function, because entry.recompute() is going to recycle\r\n            // the entry object without recomputing anything, anyway.\r\n            return void 0;\r\n        }\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.args = args;\r\n        }\r\n        else {\r\n            entry = new Entry(originalFunction, args);\r\n            cache.set(key, entry);\r\n            entry.subscribe = options.subscribe;\r\n            if (disposable) {\r\n                entry.reportOrphan = function () { return cache.delete(key); };\r\n            }\r\n        }\r\n        var value = entry.recompute();\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        // If options.disposable is truthy, the caller of wrap is telling us\r\n        // they don't care about the result of entry.recompute(), so we should\r\n        // avoid returning the value, so it won't be accidentally used.\r\n        return disposable ? void 0 : value;\r\n    }\r\n    optimistic.dirty = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        var child = key !== void 0 && cache.get(key);\r\n        if (child) {\r\n            child.setDirty();\r\n        }\r\n    };\r\n    return optimistic;\r\n}\n\nexport { KeyTrie, defaultMakeCacheKey, wrap };\n//# sourceMappingURL=bundle.esm.js.map\n","import { __assign, __extends } from 'tslib';\nimport { ApolloCache } from 'apollo-cache';\nimport { isTest, getQueryDefinition, assign, getDefaultValues, isEqual, getMainDefinition, getFragmentDefinitions, createFragmentMap, shouldInclude, isField, resultKeyNameFromField, isInlineFragment, mergeDeepArray, argumentsObjectFromField, getDirectiveInfoFromField, maybeDeepFreeze, isIdValue, getStoreKeyName, toIdValue, isJsonValue, canUseWeakMap, getOperationDefinition, isProduction, storeKeyNameFromField, addTypenameToDocument } from 'apollo-utilities';\nimport { wrap, KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nvar haveWarned = false;\nfunction shouldWarn() {\n    var answer = !haveWarned;\n    if (!isTest()) {\n        haveWarned = true;\n    }\n    return answer;\n}\nvar HeuristicFragmentMatcher = (function () {\n    function HeuristicFragmentMatcher() {\n    }\n    HeuristicFragmentMatcher.prototype.ensureReady = function () {\n        return Promise.resolve();\n    };\n    HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n        return true;\n    };\n    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n        if (!__typename) {\n            if (shouldWarn()) {\n                process.env.NODE_ENV === \"production\" || invariant.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n                process.env.NODE_ENV === \"production\" || invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);\n                process.env.NODE_ENV === \"production\" || invariant.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" +\n                    \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n            }\n            return 'heuristic';\n        }\n        if (__typename === typeCondition) {\n            return true;\n        }\n        if (shouldWarn()) {\n            process.env.NODE_ENV === \"production\" || invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +\n                'queries contain union or interface types. Apollo Client will not be ' +\n                'able to accurately map fragments. To make this error go away, use ' +\n                'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n                'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');\n        }\n        return 'heuristic';\n    };\n    return HeuristicFragmentMatcher;\n}());\nvar IntrospectionFragmentMatcher = (function () {\n    function IntrospectionFragmentMatcher(options) {\n        if (options && options.introspectionQueryResultData) {\n            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n            this.isReady = true;\n        }\n        else {\n            this.isReady = false;\n        }\n        this.match = this.match.bind(this);\n    }\n    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        process.env.NODE_ENV === \"production\" ? invariant(this.isReady, 1) : invariant(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n        process.env.NODE_ENV === \"production\" ? invariant(__typename, 2) : invariant(__typename, \"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n        if (__typename === typeCondition) {\n            return true;\n        }\n        var implementingTypes = this.possibleTypesMap[typeCondition];\n        if (__typename &&\n            implementingTypes &&\n            implementingTypes.indexOf(__typename) > -1) {\n            return true;\n        }\n        return false;\n    };\n    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n        var typeMap = {};\n        introspectionResultData.__schema.types.forEach(function (type) {\n            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });\n            }\n        });\n        return typeMap;\n    };\n    return IntrospectionFragmentMatcher;\n}());\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar DepTrackingCache = (function () {\n    function DepTrackingCache(data) {\n        var _this = this;\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n        this.depend = wrap(function (dataId) { return _this.data[dataId]; }, {\n            disposable: true,\n            makeCacheKey: function (dataId) {\n                return dataId;\n            },\n        });\n    }\n    DepTrackingCache.prototype.toObject = function () {\n        return this.data;\n    };\n    DepTrackingCache.prototype.get = function (dataId) {\n        this.depend(dataId);\n        return this.data[dataId];\n    };\n    DepTrackingCache.prototype.set = function (dataId, value) {\n        var oldValue = this.data[dataId];\n        if (value !== oldValue) {\n            this.data[dataId] = value;\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.delete = function (dataId) {\n        if (hasOwn.call(this.data, dataId)) {\n            delete this.data[dataId];\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.clear = function () {\n        this.replace(null);\n    };\n    DepTrackingCache.prototype.replace = function (newData) {\n        var _this = this;\n        if (newData) {\n            Object.keys(newData).forEach(function (dataId) {\n                _this.set(dataId, newData[dataId]);\n            });\n            Object.keys(this.data).forEach(function (dataId) {\n                if (!hasOwn.call(newData, dataId)) {\n                    _this.delete(dataId);\n                }\n            });\n        }\n        else {\n            Object.keys(this.data).forEach(function (dataId) {\n                _this.delete(dataId);\n            });\n        }\n    };\n    return DepTrackingCache;\n}());\nfunction defaultNormalizedCacheFactory(seed) {\n    return new DepTrackingCache(seed);\n}\n\nvar StoreReader = (function () {\n    function StoreReader(_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;\n        var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;\n        this.freezeResults = freezeResults;\n        this.executeStoreQuery = wrap(function (options) {\n            return executeStoreQuery.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;\n                if (contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSelectionSet = wrap(function (options) {\n            return executeSelectionSet.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            return executeSubSelectedArray.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));\n                }\n            }\n        });\n    }\n    StoreReader.prototype.readQueryFromStore = function (options) {\n        return this.diffQueryAgainstStore(__assign(__assign({}, options), { returnPartialData: false })).result;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;\n        var queryDefinition = getQueryDefinition(query);\n        variables = assign({}, getDefaultValues(queryDefinition), variables);\n        var context = {\n            store: store,\n            dataIdFromObject: config && config.dataIdFromObject,\n            cacheRedirects: (config && config.cacheRedirects) || {},\n        };\n        var execResult = this.executeStoreQuery({\n            query: query,\n            rootValue: {\n                type: 'id',\n                id: rootId,\n                generated: true,\n                typename: 'Query',\n            },\n            contextValue: context,\n            variableValues: variables,\n            fragmentMatcher: fragmentMatcherFunction,\n        });\n        var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n        if (hasMissingFields && !returnPartialData) {\n            execResult.missing.forEach(function (info) {\n                if (info.tolerable)\n                    return;\n                throw process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError(\"Can't find field \" + info.fieldName + \" on object \" + JSON.stringify(info.object, null, 2) + \".\");\n            });\n        }\n        if (previousResult) {\n            if (isEqual(previousResult, execResult.result)) {\n                execResult.result = previousResult;\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !hasMissingFields,\n        };\n    };\n    StoreReader.prototype.executeStoreQuery = function (_a) {\n        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;\n        var mainDefinition = getMainDefinition(query);\n        var fragments = getFragmentDefinitions(query);\n        var fragmentMap = createFragmentMap(fragments);\n        var execContext = {\n            query: query,\n            fragmentMap: fragmentMap,\n            contextValue: contextValue,\n            variableValues: variableValues,\n            fragmentMatcher: fragmentMatcher,\n        };\n        return this.executeSelectionSet({\n            selectionSet: mainDefinition.selectionSet,\n            rootValue: rootValue,\n            execContext: execContext,\n        });\n    };\n    StoreReader.prototype.executeSelectionSet = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;\n        var finalResult = { result: null };\n        var objectsToMerge = [];\n        var object = contextValue.store.get(rootValue.id);\n        var typename = (object && object.__typename) ||\n            (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n            void 0;\n        function handleMissing(result) {\n            var _a;\n            if (result.missing) {\n                finalResult.missing = finalResult.missing || [];\n                (_a = finalResult.missing).push.apply(_a, result.missing);\n            }\n            return result.result;\n        }\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));\n                if (typeof fieldResult !== 'undefined') {\n                    objectsToMerge.push((_a = {},\n                        _a[resultKeyNameFromField(selection)] = fieldResult,\n                        _a));\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = fragmentMap[selection.name.value];\n                    if (!fragment) {\n                        throw process.env.NODE_ENV === \"production\" ? new InvariantError(9) : new InvariantError(\"No fragment named \" + selection.name.value);\n                    }\n                }\n                var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;\n                var match = !typeCondition ||\n                    execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n                if (match) {\n                    var fragmentExecResult = _this.executeSelectionSet({\n                        selectionSet: fragment.selectionSet,\n                        rootValue: rootValue,\n                        execContext: execContext,\n                    });\n                    if (match === 'heuristic' && fragmentExecResult.missing) {\n                        fragmentExecResult = __assign(__assign({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function (info) {\n                                return __assign(__assign({}, info), { tolerable: true });\n                            }) });\n                    }\n                    objectsToMerge.push(handleMissing(fragmentExecResult));\n                }\n            }\n        });\n        finalResult.result = mergeDeepArray(objectsToMerge);\n        if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n            Object.freeze(finalResult.result);\n        }\n        return finalResult;\n    };\n    StoreReader.prototype.executeField = function (object, typename, field, execContext) {\n        var variables = execContext.variableValues, contextValue = execContext.contextValue;\n        var fieldName = field.name.value;\n        var args = argumentsObjectFromField(field, variables);\n        var info = {\n            resultKey: resultKeyNameFromField(field),\n            directives: getDirectiveInfoFromField(field, variables),\n        };\n        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);\n        if (Array.isArray(readStoreResult.result)) {\n            return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({\n                field: field,\n                array: readStoreResult.result,\n                execContext: execContext,\n            }));\n        }\n        if (!field.selectionSet) {\n            assertSelectionSetForIdValue(field, readStoreResult.result);\n            if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n                maybeDeepFreeze(readStoreResult);\n            }\n            return readStoreResult;\n        }\n        if (readStoreResult.result == null) {\n            return readStoreResult;\n        }\n        return this.combineExecResults(readStoreResult, this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            rootValue: readStoreResult.result,\n            execContext: execContext,\n        }));\n    };\n    StoreReader.prototype.combineExecResults = function () {\n        var execResults = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            execResults[_i] = arguments[_i];\n        }\n        var missing;\n        execResults.forEach(function (execResult) {\n            if (execResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, execResult.missing);\n            }\n        });\n        return {\n            result: execResults.pop().result,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.executeSubSelectedArray = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, execContext = _a.execContext;\n        var missing;\n        function handleMissing(childResult) {\n            if (childResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, childResult.missing);\n            }\n            return childResult.result;\n        }\n        array = array.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    execContext: execContext,\n                }));\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    rootValue: item,\n                    execContext: execContext,\n                }));\n            }\n            assertSelectionSetForIdValue(field, item);\n            return item;\n        });\n        if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n            Object.freeze(array);\n        }\n        return { result: array, missing: missing };\n    };\n    return StoreReader;\n}());\nfunction assertSelectionSetForIdValue(field, value) {\n    if (!field.selectionSet && isIdValue(value)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(10) : new InvariantError(\"Missing selection set for object of type \" + value.typename + \" returned for query field \" + field.name.value);\n    }\n}\nfunction defaultFragmentMatcher() {\n    return true;\n}\nfunction assertIdValue(idValue) {\n    process.env.NODE_ENV === \"production\" ? invariant(isIdValue(idValue), 11) : invariant(isIdValue(idValue), \"Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.\");\n}\nfunction readStoreResolver(object, typename, fieldName, args, context, _a) {\n    var resultKey = _a.resultKey, directives = _a.directives;\n    var storeKeyName = fieldName;\n    if (args || directives) {\n        storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n    }\n    var fieldValue = void 0;\n    if (object) {\n        fieldValue = object[storeKeyName];\n        if (typeof fieldValue === 'undefined' &&\n            context.cacheRedirects &&\n            typeof typename === 'string') {\n            var type = context.cacheRedirects[typename];\n            if (type) {\n                var resolver = type[fieldName];\n                if (resolver) {\n                    fieldValue = resolver(object, args, {\n                        getCacheKey: function (storeObj) {\n                            var id = context.dataIdFromObject(storeObj);\n                            return id && toIdValue({\n                                id: id,\n                                typename: storeObj.__typename,\n                            });\n                        },\n                    });\n                }\n            }\n        }\n    }\n    if (typeof fieldValue === 'undefined') {\n        return {\n            result: fieldValue,\n            missing: [{\n                    object: object,\n                    fieldName: storeKeyName,\n                    tolerable: false,\n                }],\n        };\n    }\n    if (isJsonValue(fieldValue)) {\n        fieldValue = fieldValue.json;\n    }\n    return {\n        result: fieldValue,\n    };\n}\n\nvar ObjectCache = (function () {\n    function ObjectCache(data) {\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n    }\n    ObjectCache.prototype.toObject = function () {\n        return this.data;\n    };\n    ObjectCache.prototype.get = function (dataId) {\n        return this.data[dataId];\n    };\n    ObjectCache.prototype.set = function (dataId, value) {\n        this.data[dataId] = value;\n    };\n    ObjectCache.prototype.delete = function (dataId) {\n        this.data[dataId] = void 0;\n    };\n    ObjectCache.prototype.clear = function () {\n        this.data = Object.create(null);\n    };\n    ObjectCache.prototype.replace = function (newData) {\n        this.data = newData || Object.create(null);\n    };\n    return ObjectCache;\n}());\nfunction defaultNormalizedCacheFactory$1(seed) {\n    return new ObjectCache(seed);\n}\n\nvar WriteError = (function (_super) {\n    __extends(WriteError, _super);\n    function WriteError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'WriteError';\n        return _this;\n    }\n    return WriteError;\n}(Error));\nfunction enhanceErrorWithDocument(error, document) {\n    var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + JSON.stringify(document));\n    enhancedError.message += '\\n' + error.message;\n    enhancedError.stack = error.stack;\n    return enhancedError;\n}\nvar StoreWriter = (function () {\n    function StoreWriter() {\n    }\n    StoreWriter.prototype.writeQueryToStore = function (_a) {\n        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        return this.writeResultToStore({\n            dataId: 'ROOT_QUERY',\n            result: result,\n            document: query,\n            store: store,\n            variables: variables,\n            dataIdFromObject: dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n    };\n    StoreWriter.prototype.writeResultToStore = function (_a) {\n        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        var operationDefinition = getOperationDefinition(document);\n        try {\n            return this.writeSelectionSetToStore({\n                result: result,\n                dataId: dataId,\n                selectionSet: operationDefinition.selectionSet,\n                context: {\n                    store: store,\n                    processedData: {},\n                    variables: assign({}, getDefaultValues(operationDefinition), variables),\n                    dataIdFromObject: dataIdFromObject,\n                    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n                    fragmentMatcherFunction: fragmentMatcherFunction,\n                },\n            });\n        }\n        catch (e) {\n            throw enhanceErrorWithDocument(e, document);\n        }\n    };\n    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n        var _this = this;\n        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;\n        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    _this.writeFieldToStore({\n                        dataId: dataId,\n                        value: value,\n                        field: selection,\n                        context: context,\n                    });\n                }\n                else {\n                    var isDefered = false;\n                    var isClient = false;\n                    if (selection.directives && selection.directives.length) {\n                        isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });\n                        isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });\n                    }\n                    if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n                        process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                    }\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = (fragmentMap || {})[selection.name.value];\n                    process.env.NODE_ENV === \"production\" ? invariant(fragment, 3) : invariant(fragment, \"No fragment named \" + selection.name.value + \".\");\n                }\n                var matches = true;\n                if (context.fragmentMatcherFunction && fragment.typeCondition) {\n                    var id = dataId || 'self';\n                    var idValue = toIdValue({ id: id, typename: undefined });\n                    var fakeContext = {\n                        store: new ObjectCache((_a = {}, _a[id] = result, _a)),\n                        cacheRedirects: {},\n                    };\n                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n                    if (!isProduction() && match === 'heuristic') {\n                        process.env.NODE_ENV === \"production\" || invariant.error('WARNING: heuristic fragment matching going on!');\n                    }\n                    matches = !!match;\n                }\n                if (matches) {\n                    _this.writeSelectionSetToStore({\n                        result: result,\n                        selectionSet: fragment.selectionSet,\n                        dataId: dataId,\n                        context: context,\n                    });\n                }\n            }\n        });\n        return store;\n    };\n    StoreWriter.prototype.writeFieldToStore = function (_a) {\n        var _b;\n        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;\n        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;\n        var storeValue;\n        var storeObject;\n        var storeFieldName = storeKeyNameFromField(field, variables);\n        if (!field.selectionSet || value === null) {\n            storeValue =\n                value != null && typeof value === 'object'\n                    ?\n                        { type: 'json', json: value }\n                    :\n                        value;\n        }\n        else if (Array.isArray(value)) {\n            var generatedId = dataId + \".\" + storeFieldName;\n            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n        }\n        else {\n            var valueDataId = dataId + \".\" + storeFieldName;\n            var generated = true;\n            if (!isGeneratedId(valueDataId)) {\n                valueDataId = '$' + valueDataId;\n            }\n            if (dataIdFromObject) {\n                var semanticId = dataIdFromObject(value);\n                process.env.NODE_ENV === \"production\" ? invariant(!semanticId || !isGeneratedId(semanticId), 4) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n                if (semanticId ||\n                    (typeof semanticId === 'number' && semanticId === 0)) {\n                    valueDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(valueDataId, field, context.processedData)) {\n                this.writeSelectionSetToStore({\n                    dataId: valueDataId,\n                    result: value,\n                    selectionSet: field.selectionSet,\n                    context: context,\n                });\n            }\n            var typename = value.__typename;\n            storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);\n            storeObject = store.get(dataId);\n            var escapedId = storeObject && storeObject[storeFieldName];\n            if (escapedId !== storeValue && isIdValue(escapedId)) {\n                var hadTypename = escapedId.typename !== undefined;\n                var hasTypename = typename !== undefined;\n                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n                process.env.NODE_ENV === \"production\" ? invariant(!generated || escapedId.generated || typenameChanged, 5) : invariant(!generated || escapedId.generated || typenameChanged, \"Store error: the application attempted to write an object with no provided id but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n                process.env.NODE_ENV === \"production\" ? invariant(!hadTypename || hasTypename, 6) : invariant(!hadTypename || hasTypename, \"Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n                if (escapedId.generated) {\n                    if (typenameChanged) {\n                        if (!generated) {\n                            store.delete(escapedId.id);\n                        }\n                    }\n                    else {\n                        mergeWithGenerated(escapedId.id, storeValue.id, store);\n                    }\n                }\n            }\n        }\n        storeObject = store.get(dataId);\n        if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n            store.set(dataId, __assign(__assign({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));\n        }\n    };\n    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n        var _this = this;\n        return value.map(function (item, index) {\n            if (item === null) {\n                return null;\n            }\n            var itemDataId = generatedId + \".\" + index;\n            if (Array.isArray(item)) {\n                return _this.processArrayValue(item, itemDataId, selectionSet, context);\n            }\n            var generated = true;\n            if (context.dataIdFromObject) {\n                var semanticId = context.dataIdFromObject(item);\n                if (semanticId) {\n                    itemDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n                _this.writeSelectionSetToStore({\n                    dataId: itemDataId,\n                    result: item,\n                    selectionSet: selectionSet,\n                    context: context,\n                });\n            }\n            return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n        });\n    };\n    return StoreWriter;\n}());\nfunction isGeneratedId(id) {\n    return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n    if (generatedKey === realKey) {\n        return false;\n    }\n    var generated = cache.get(generatedKey);\n    var real = cache.get(realKey);\n    var madeChanges = false;\n    Object.keys(generated).forEach(function (key) {\n        var value = generated[key];\n        var realValue = real[key];\n        if (isIdValue(value) &&\n            isGeneratedId(value.id) &&\n            isIdValue(realValue) &&\n            !isEqual(value, realValue) &&\n            mergeWithGenerated(value.id, realValue.id, cache)) {\n            madeChanges = true;\n        }\n    });\n    cache.delete(generatedKey);\n    var newRealValue = __assign(__assign({}, generated), real);\n    if (isEqual(newRealValue, real)) {\n        return madeChanges;\n    }\n    cache.set(realKey, newRealValue);\n    return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n    if (!processedData) {\n        return false;\n    }\n    if (processedData[dataId]) {\n        if (processedData[dataId].indexOf(field) >= 0) {\n            return true;\n        }\n        else {\n            processedData[dataId].push(field);\n        }\n    }\n    else {\n        processedData[dataId] = [field];\n    }\n    return false;\n}\n\nvar defaultConfig = {\n    fragmentMatcher: new HeuristicFragmentMatcher(),\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    freezeResults: false,\n};\nfunction defaultDataIdFromObject(result) {\n    if (result.__typename) {\n        if (result.id !== undefined) {\n            return result.__typename + \":\" + result.id;\n        }\n        if (result._id !== undefined) {\n            return result.__typename + \":\" + result._id;\n        }\n    }\n    return null;\n}\nvar hasOwn$1 = Object.prototype.hasOwnProperty;\nvar OptimisticCacheLayer = (function (_super) {\n    __extends(OptimisticCacheLayer, _super);\n    function OptimisticCacheLayer(optimisticId, parent, transaction) {\n        var _this = _super.call(this, Object.create(null)) || this;\n        _this.optimisticId = optimisticId;\n        _this.parent = parent;\n        _this.transaction = transaction;\n        return _this;\n    }\n    OptimisticCacheLayer.prototype.toObject = function () {\n        return __assign(__assign({}, this.parent.toObject()), this.data);\n    };\n    OptimisticCacheLayer.prototype.get = function (dataId) {\n        return hasOwn$1.call(this.data, dataId)\n            ? this.data[dataId]\n            : this.parent.get(dataId);\n    };\n    return OptimisticCacheLayer;\n}(ObjectCache));\nvar InMemoryCache = (function (_super) {\n    __extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.typenameDocumentCache = new Map();\n        _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);\n        _this.silenceBroadcast = false;\n        _this.config = __assign(__assign({}, defaultConfig), config);\n        if (_this.config.customResolvers) {\n            process.env.NODE_ENV === \"production\" || invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.customResolvers;\n        }\n        if (_this.config.cacheResolvers) {\n            process.env.NODE_ENV === \"production\" || invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.cacheResolvers;\n        }\n        _this.addTypename = !!_this.config.addTypename;\n        _this.data = _this.config.resultCaching\n            ? new DepTrackingCache()\n            : new ObjectCache();\n        _this.optimisticData = _this.data;\n        _this.storeWriter = new StoreWriter();\n        _this.storeReader = new StoreReader({\n            cacheKeyRoot: _this.cacheKeyRoot,\n            freezeResults: config.freezeResults,\n        });\n        var cache = _this;\n        var maybeBroadcastWatch = cache.maybeBroadcastWatch;\n        _this.maybeBroadcastWatch = wrap(function (c) {\n            return maybeBroadcastWatch.call(_this, c);\n        }, {\n            makeCacheKey: function (c) {\n                if (c.optimistic) {\n                    return;\n                }\n                if (c.previousResult) {\n                    return;\n                }\n                if (cache.data instanceof DepTrackingCache) {\n                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));\n                }\n            }\n        });\n        return _this;\n    }\n    InMemoryCache.prototype.restore = function (data) {\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).toObject();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        if (typeof options.rootId === 'string' &&\n            typeof this.data.get(options.rootId) === 'undefined') {\n            return null;\n        }\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.readQueryFromStore({\n            store: options.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(options.query),\n            variables: options.variables,\n            rootId: options.rootId,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            previousResult: options.previousResult,\n            config: this.config,\n        }) || null;\n    };\n    InMemoryCache.prototype.write = function (write) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        this.storeWriter.writeResultToStore({\n            dataId: write.dataId,\n            result: write.result,\n            variables: write.variables,\n            document: this.transformDocument(write.query),\n            store: this.data,\n            dataIdFromObject: this.config.dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.diff = function (query) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.diffQueryAgainstStore({\n            store: query.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(query.query),\n            variables: query.variables,\n            returnPartialData: query.returnPartialData,\n            previousResult: query.previousResult,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            config: this.config,\n        });\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        this.watches.add(watch);\n        return function () {\n            _this.watches.delete(watch);\n        };\n    };\n    InMemoryCache.prototype.evict = function (query) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(7) : new InvariantError(\"eviction is not implemented on InMemory Cache\");\n    };\n    InMemoryCache.prototype.reset = function () {\n        this.data.clear();\n        this.broadcastWatches();\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var toReapply = [];\n        var removedCount = 0;\n        var layer = this.optimisticData;\n        while (layer instanceof OptimisticCacheLayer) {\n            if (layer.optimisticId === idToRemove) {\n                ++removedCount;\n            }\n            else {\n                toReapply.push(layer);\n            }\n            layer = layer.parent;\n        }\n        if (removedCount > 0) {\n            this.optimisticData = layer;\n            while (toReapply.length > 0) {\n                var layer_1 = toReapply.pop();\n                this.performTransaction(layer_1.transaction, layer_1.optimisticId);\n            }\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;\n        this.silenceBroadcast = true;\n        if (typeof optimisticId === 'string') {\n            this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);\n        }\n        try {\n            transaction(this);\n        }\n        finally {\n            this.silenceBroadcast = silenceBroadcast;\n            this.data = data;\n        }\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {\n        return this.performTransaction(transaction, id);\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        if (this.addTypename) {\n            var result = this.typenameDocumentCache.get(document);\n            if (!result) {\n                result = addTypenameToDocument(document);\n                this.typenameDocumentCache.set(document, result);\n                this.typenameDocumentCache.set(result, result);\n            }\n            return result;\n        }\n        return document;\n    };\n    InMemoryCache.prototype.broadcastWatches = function () {\n        var _this = this;\n        if (!this.silenceBroadcast) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });\n        }\n    };\n    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {\n        c.callback(this.diff({\n            query: c.query,\n            variables: c.variables,\n            previousResult: c.previousResult && c.previousResult(),\n            optimistic: c.optimistic,\n        }));\n    };\n    return InMemoryCache;\n}(ApolloCache));\n\nexport { HeuristicFragmentMatcher, InMemoryCache, IntrospectionFragmentMatcher, ObjectCache, StoreReader, StoreWriter, WriteError, assertIdValue, defaultDataIdFromObject, defaultNormalizedCacheFactory$1 as defaultNormalizedCacheFactory, enhanceErrorWithDocument };\n//# sourceMappingURL=bundle.esm.js.map\n"],"sourceRoot":""}