{"version":3,"sources":["webpack://pbm/./node_modules/optimism/lib/bundle.esm.js"],"names":["defaultDispose","Cache","max","dispose","Infinity","this","map","Map","newest","oldest","prototype","has","key","get","entry","getEntry","value","older","newer","set","clean","size","delete","parentEntrySlot","maybeUnsubscribe","entryOrDep","unsubscribe","emptySetPool","assert","condition","optionalMessage","Error","valueGet","length","Entry","fn","parents","Set","childValues","dirtyChildren","dirty","recomputing","deps","count","peek","mightBeDirty","recompute","args","child","parent","getValue","add","reportDirtyChild","reportCleanChild","forgetChildren","withValue","recomputeNewValue","subscribe","apply","e","setDirty","maybeSubscribe","reportClean","setClean","reallyRecompute","reportDirty","_this","forEach","forgetChild","dependOn","dep","pop","forgetDeps","clear","push","a","b","len","childValue","slice","removeDirtyChild","dc","_value","options","depsByKey","depend","dep_1","keyTrie","WeakMap","defaultMakeCacheKey","_i","arguments","lookupArray","caches","wrap","originalFunction","Object","create","cache","Math","pow","keyArgs","makeCacheKey","optimistic","Array","call","hasValue","lookup","forget"],"mappings":"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","file":"npm.optimism.fd5647aa181e29ae7e67.js","sourcesContent":["import { Trie } from '@wry/trie';\nexport { Trie as KeyTrie } from '@wry/trie';\nimport { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nfunction maybeUnsubscribe(entryOrDep) {\r\n    var unsubscribe = entryOrDep.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entryOrDep.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn) {\r\n        this.fn = fn;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        this.deps = null;\r\n        ++Entry.count;\r\n    }\r\n    Entry.prototype.peek = function () {\r\n        if (this.value.length === 1 && !mightBeDirty(this)) {\r\n            return this.value[0];\r\n        }\r\n    };\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function (args) {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        rememberParent(this);\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this, args)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        forgetChildren(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.prototype.dependOn = function (dep) {\r\n        dep.add(this);\r\n        if (!this.deps) {\r\n            this.deps = emptySetPool.pop() || new Set();\r\n        }\r\n        this.deps.add(dep);\r\n    };\r\n    Entry.prototype.forgetDeps = function () {\r\n        var _this = this;\r\n        if (this.deps) {\r\n            this.deps.forEach(function (dep) { return dep.delete(_this); });\r\n            this.deps.clear();\r\n            emptySetPool.push(this.deps);\r\n            this.deps = null;\r\n        }\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry, args) {\r\n    forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\r\n    if (maybeSubscribe(entry, args)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry, args) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    if (parent.childValues.size > 0) {\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n        });\r\n    }\r\n    // Remove this parent Entry from any sets to which it was added by the\r\n    // addToSet method.\r\n    parent.forgetDeps();\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry, args) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\n\nfunction dep(options) {\r\n    var depsByKey = new Map();\r\n    var subscribe = options && options.subscribe;\r\n    function depend(key) {\r\n        var parent = parentEntrySlot.getValue();\r\n        if (parent) {\r\n            var dep_1 = depsByKey.get(key);\r\n            if (!dep_1) {\r\n                depsByKey.set(key, dep_1 = new Set);\r\n            }\r\n            parent.dependOn(dep_1);\r\n            if (typeof subscribe === \"function\") {\r\n                maybeUnsubscribe(dep_1);\r\n                dep_1.unsubscribe = subscribe(key);\r\n            }\r\n        }\r\n    }\r\n    depend.dirty = function dirty(key) {\r\n        var dep = depsByKey.get(key);\r\n        if (dep) {\r\n            dep.forEach(function (entry) { return entry.setDirty(); });\r\n            depsByKey.delete(key);\r\n            maybeUnsubscribe(dep);\r\n        }\r\n    };\r\n    return depend;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new Trie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var keyArgs = options.keyArgs || (function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return args;\r\n    });\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        var key = makeCacheKey.apply(null, keyArgs.apply(null, arguments));\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var entry = cache.get(key);\r\n        if (!entry) {\r\n            cache.set(key, entry = new Entry(originalFunction));\r\n            entry.subscribe = options.subscribe;\r\n        }\r\n        var value = entry.recompute(Array.prototype.slice.call(arguments));\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        return value;\r\n    }\r\n    function lookup() {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key !== void 0) {\r\n            return cache.get(key);\r\n        }\r\n    }\r\n    optimistic.dirty = function () {\r\n        var entry = lookup.apply(null, arguments);\r\n        if (entry) {\r\n            entry.setDirty();\r\n        }\r\n    };\r\n    optimistic.peek = function () {\r\n        var entry = lookup.apply(null, arguments);\r\n        if (entry) {\r\n            return entry.peek();\r\n        }\r\n    };\r\n    optimistic.forget = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        return key !== void 0 && cache.delete(key);\r\n    };\r\n    return optimistic;\r\n}\n\nexport { defaultMakeCacheKey, dep, wrap };\n//# sourceMappingURL=bundle.esm.js.map\n"],"sourceRoot":""}