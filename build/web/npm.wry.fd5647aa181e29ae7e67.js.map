{"version":3,"sources":["webpack://pbm/./node_modules/@wry/context/lib/context.esm.js","webpack://pbm/./node_modules/@wry/equality/lib/equality.esm.js","webpack://pbm/./node_modules/@wry/trie/lib/trie.esm.js"],"names":["currentContext","MISSING_VALUE","idCounter","globalKey","host","Array","Slot","this","id","Date","now","Math","random","toString","slice","join","prototype","hasValue","context_1","parent","slots","value","getValue","withValue","callback","args","thisArg","_a","__proto__","apply","bind","context","saved","arguments","noContext","Object","defineProperty","enumerable","writable","configurable","hasOwnProperty","previousComparisons","Map","equal","a","b","check","clear","aTag","call","length","previouslyCompared","aKeys","keys","bKeys","keyCount","k","key","name","message","size","aIterator","entries","isMap","info","next","done","aKey","aValue","has","get","bSet","set","Set","add","defaultMakeData","create","forEach","Trie","weakness","makeData","lookup","array","_i","lookupArray","node","getChildTrie","data","map","isObjRef","weak","WeakMap","strong","child"],"mappings":"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","file":"npm.wry.fd5647aa181e29ae7e67.js","sourcesContent":["// This currentContext variable will only be used if the makeSlotClass\r\n// function is called, which happens only if this is the first copy of the\r\n// @wry/context package to be imported.\r\nvar currentContext = null;\r\n// This unique internal object is used to denote the absence of a value\r\n// for a given Slot, and is never exposed to outside code.\r\nvar MISSING_VALUE = {};\r\nvar idCounter = 1;\r\n// Although we can't do anything about the cost of duplicated code from\r\n// accidentally bundling multiple copies of the @wry/context package, we can\r\n// avoid creating the Slot class more than once using makeSlotClass.\r\nvar makeSlotClass = function () { return /** @class */ (function () {\r\n    function Slot() {\r\n        // If you have a Slot object, you can find out its slot.id, but you cannot\r\n        // guess the slot.id of a Slot you don't have access to, thanks to the\r\n        // randomized suffix.\r\n        this.id = [\r\n            \"slot\",\r\n            idCounter++,\r\n            Date.now(),\r\n            Math.random().toString(36).slice(2),\r\n        ].join(\":\");\r\n    }\r\n    Slot.prototype.hasValue = function () {\r\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\r\n            // We use the Slot object iself as a key to its value, which means the\r\n            // value cannot be obtained without a reference to the Slot object.\r\n            if (this.id in context_1.slots) {\r\n                var value = context_1.slots[this.id];\r\n                if (value === MISSING_VALUE)\r\n                    break;\r\n                if (context_1 !== currentContext) {\r\n                    // Cache the value in currentContext.slots so the next lookup will\r\n                    // be faster. This caching is safe because the tree of contexts and\r\n                    // the values of the slots are logically immutable.\r\n                    currentContext.slots[this.id] = value;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        if (currentContext) {\r\n            // If a value was not found for this Slot, it's never going to be found\r\n            // no matter how many times we look it up, so we might as well cache\r\n            // the absence of the value, too.\r\n            currentContext.slots[this.id] = MISSING_VALUE;\r\n        }\r\n        return false;\r\n    };\r\n    Slot.prototype.getValue = function () {\r\n        if (this.hasValue()) {\r\n            return currentContext.slots[this.id];\r\n        }\r\n    };\r\n    Slot.prototype.withValue = function (value, callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        var _a;\r\n        var slots = (_a = {\r\n                __proto__: null\r\n            },\r\n            _a[this.id] = value,\r\n            _a);\r\n        var parent = currentContext;\r\n        currentContext = { parent: parent, slots: slots };\r\n        try {\r\n            // Function.prototype.apply allows the arguments array argument to be\r\n            // omitted or undefined, so args! is fine here.\r\n            return callback.apply(thisArg, args);\r\n        }\r\n        finally {\r\n            currentContext = parent;\r\n        }\r\n    };\r\n    // Capture the current context and wrap a callback function so that it\r\n    // reestablishes the captured context when called.\r\n    Slot.bind = function (callback) {\r\n        var context = currentContext;\r\n        return function () {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = context;\r\n                return callback.apply(this, arguments);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        };\r\n    };\r\n    // Immediately run a callback function without any captured context.\r\n    Slot.noContext = function (callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        if (currentContext) {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = null;\r\n                // Function.prototype.apply allows the arguments array argument to be\r\n                // omitted or undefined, so args! is fine here.\r\n                return callback.apply(thisArg, args);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        }\r\n        else {\r\n            return callback.apply(thisArg, args);\r\n        }\r\n    };\r\n    return Slot;\r\n}()); };\r\n// We store a single global implementation of the Slot class as a permanent\r\n// non-enumerable symbol property of the Array constructor. This obfuscation\r\n// does nothing to prevent access to the Slot class, but at least it ensures\r\n// the implementation (i.e. currentContext) cannot be tampered with, and all\r\n// copies of the @wry/context package (hopefully just one) will share the\r\n// same Slot implementation. Since the first copy of the @wry/context package\r\n// to be imported wins, this technique imposes a very high cost for any\r\n// future breaking changes to the Slot class.\r\nvar globalKey = \"@wry/context:Slot\";\r\nvar host = Array;\r\nvar Slot = host[globalKey] || function () {\r\n    var Slot = makeSlotClass();\r\n    try {\r\n        Object.defineProperty(host, globalKey, {\r\n            value: host[globalKey] = Slot,\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: false,\r\n        });\r\n    }\r\n    finally {\r\n        return Slot;\r\n    }\r\n}();\n\nvar bind = Slot.bind, noContext = Slot.noContext;\r\nfunction setTimeoutWithContext(callback, delay) {\r\n    return setTimeout(bind(callback), delay);\r\n}\r\n// Turn any generator function into an async function (using yield instead\r\n// of await), with context automatically preserved across yields.\r\nfunction asyncFromGen(genFn) {\r\n    return function () {\r\n        var gen = genFn.apply(this, arguments);\r\n        var boundNext = bind(gen.next);\r\n        var boundThrow = bind(gen.throw);\r\n        return new Promise(function (resolve, reject) {\r\n            function invoke(method, argument) {\r\n                try {\r\n                    var result = method.call(gen, argument);\r\n                }\r\n                catch (error) {\r\n                    return reject(error);\r\n                }\r\n                var next = result.done ? resolve : invokeNext;\r\n                if (isPromiseLike(result.value)) {\r\n                    result.value.then(next, result.done ? reject : invokeThrow);\r\n                }\r\n                else {\r\n                    next(result.value);\r\n                }\r\n            }\r\n            var invokeNext = function (value) { return invoke(boundNext, value); };\r\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\r\n            invokeNext();\r\n        });\r\n    };\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value && typeof value.then === \"function\";\r\n}\r\n// If you use the fibers npm package to implement coroutines in Node.js,\r\n// you should call this function at least once to ensure context management\r\n// remains coherent across any yields.\r\nvar wrappedFibers = [];\r\nfunction wrapYieldingFiberMethods(Fiber) {\r\n    // There can be only one implementation of Fiber per process, so this array\r\n    // should never grow longer than one element.\r\n    if (wrappedFibers.indexOf(Fiber) < 0) {\r\n        var wrap = function (obj, method) {\r\n            var fn = obj[method];\r\n            obj[method] = function () {\r\n                return noContext(fn, arguments, this);\r\n            };\r\n        };\r\n        // These methods can yield, according to\r\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\r\n        wrap(Fiber, \"yield\");\r\n        wrap(Fiber.prototype, \"run\");\r\n        wrap(Fiber.prototype, \"throwInto\");\r\n        wrappedFibers.push(Fiber);\r\n    }\r\n    return Fiber;\r\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };\n//# sourceMappingURL=context.esm.js.map\n","var _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;\r\nvar previousComparisons = new Map();\r\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\r\nfunction equal(a, b) {\r\n    try {\r\n        return check(a, b);\r\n    }\r\n    finally {\r\n        previousComparisons.clear();\r\n    }\r\n}\r\nfunction check(a, b) {\r\n    // If the two values are strictly equal, our job is easy.\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    // Object.prototype.toString returns a representation of the runtime type of\r\n    // the given value that is considerably more precise than typeof.\r\n    var aTag = toString.call(a);\r\n    var bTag = toString.call(b);\r\n    // If the runtime types of a and b are different, they could maybe be equal\r\n    // under some interpretation of equality, but for simplicity and performance\r\n    // we just return false instead.\r\n    if (aTag !== bTag) {\r\n        return false;\r\n    }\r\n    switch (aTag) {\r\n        case '[object Array]':\r\n            // Arrays are a lot like other objects, but we can cheaply compare their\r\n            // lengths as a short-cut before comparing their elements.\r\n            if (a.length !== b.length)\r\n                return false;\r\n        // Fall through to object case...\r\n        case '[object Object]': {\r\n            if (previouslyCompared(a, b))\r\n                return true;\r\n            var aKeys = Object.keys(a);\r\n            var bKeys = Object.keys(b);\r\n            // If `a` and `b` have a different number of enumerable keys, they\r\n            // must be different.\r\n            var keyCount = aKeys.length;\r\n            if (keyCount !== bKeys.length)\r\n                return false;\r\n            // Now make sure they have the same keys.\r\n            for (var k = 0; k < keyCount; ++k) {\r\n                if (!hasOwnProperty.call(b, aKeys[k])) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Finally, check deep equality of all child properties.\r\n            for (var k = 0; k < keyCount; ++k) {\r\n                var key = aKeys[k];\r\n                if (!check(a[key], b[key])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        case '[object Error]':\r\n            return a.name === b.name && a.message === b.message;\r\n        case '[object Number]':\r\n            // Handle NaN, which is !== itself.\r\n            if (a !== a)\r\n                return b !== b;\r\n        // Fall through to shared +a === +b case...\r\n        case '[object Boolean]':\r\n        case '[object Date]':\r\n            return +a === +b;\r\n        case '[object RegExp]':\r\n        case '[object String]':\r\n            return a == \"\" + b;\r\n        case '[object Map]':\r\n        case '[object Set]': {\r\n            if (a.size !== b.size)\r\n                return false;\r\n            if (previouslyCompared(a, b))\r\n                return true;\r\n            var aIterator = a.entries();\r\n            var isMap = aTag === '[object Map]';\r\n            while (true) {\r\n                var info = aIterator.next();\r\n                if (info.done)\r\n                    break;\r\n                // If a instanceof Set, aValue === aKey.\r\n                var _a = info.value, aKey = _a[0], aValue = _a[1];\r\n                // So this works the same way for both Set and Map.\r\n                if (!b.has(aKey)) {\r\n                    return false;\r\n                }\r\n                // However, we care about deep equality of values only when dealing\r\n                // with Map structures.\r\n                if (isMap && !check(aValue, b.get(aKey))) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    // Otherwise the values are not equal.\r\n    return false;\r\n}\r\nfunction previouslyCompared(a, b) {\r\n    // Though cyclic references can make an object graph appear infinite from the\r\n    // perspective of a depth-first traversal, the graph still contains a finite\r\n    // number of distinct object references. We use the previousComparisons cache\r\n    // to avoid comparing the same pair of object references more than once, which\r\n    // guarantees termination (even if we end up comparing every object in one\r\n    // graph to every object in the other graph, which is extremely unlikely),\r\n    // while still allowing weird isomorphic structures (like rings with different\r\n    // lengths) a chance to pass the equality test.\r\n    var bSet = previousComparisons.get(a);\r\n    if (bSet) {\r\n        // Return true here because we can be sure false will be returned somewhere\r\n        // else if the objects are not equivalent.\r\n        if (bSet.has(b))\r\n            return true;\r\n    }\r\n    else {\r\n        previousComparisons.set(a, bSet = new Set);\r\n    }\r\n    bSet.add(b);\r\n    return false;\r\n}\n\nexport default equal;\nexport { equal };\n//# sourceMappingURL=equality.esm.js.map\n","// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\r\n// object keys weakly, yet can also hold non-object keys, unlike the\r\n// native `WeakMap`.\r\n// If no makeData function is supplied, the looked-up data will be an empty,\r\n// null-prototype Object.\r\nvar defaultMakeData = function () { return Object.create(null); };\r\n// Useful for processing arguments objects as well as arrays.\r\nvar _a = Array.prototype, forEach = _a.forEach, slice = _a.slice;\r\nvar Trie = /** @class */ (function () {\r\n    function Trie(weakness, makeData) {\r\n        if (weakness === void 0) { weakness = true; }\r\n        if (makeData === void 0) { makeData = defaultMakeData; }\r\n        this.weakness = weakness;\r\n        this.makeData = makeData;\r\n    }\r\n    Trie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    Trie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        forEach.call(array, function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = this.makeData(slice.call(array)));\r\n    };\r\n    Trie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new Trie(this.weakness, this.makeData));\r\n        return child;\r\n    };\r\n    return Trie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\nexport { Trie };\n//# sourceMappingURL=trie.esm.js.map\n"],"sourceRoot":""}